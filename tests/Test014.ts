import { TestCaseView } from './TestCaseView';
import { TestCaseViewModel } from './TestCaseViewModel';
import { div, paragraph, anchor, CssRule, CssVariable, CssSimpleRule, assert, CssInlineRule, createHtml, getCssRulesInElement } from '../src/Api';
import { CssStyleSheet } from '../src/Css/CssStyleSheet';

// tslint:disable:max-classes-per-file
class TestViewModel extends TestCaseViewModel {
    constructor() {
        super({
            name: 'JS CSS Classes (Experimental)',
            descriptionHtml: `<p>Here's another experimental model that will be of limited utility, but it's kind
            of neat. It's making CSS classes (any rules, in fact, even those that aren't using class selectors) act
            more like JS classes, with inheritance and traits. Basically similar to SASS/SCSS except at runtime (my
            first version used SCSS syntax even).</p>

            <p>This isn't very useful, the same as SASS isn't very useful. Oh, I know that a number of projects
            use it, but that doesn't mean it's really worth it. The problem with CSS isn't the lack of inheritance ...
            for simple key/value collections, clipboard inheritance is annoying but functional. It isn't the lack of
            variables ... CSS variables now exist. It isn't the way scoping was deleted from the standard ... that
            can be hacked together using selectors ... but it does hurt.</p>

            <p>The problem with CSS is CSS. It's a flaming trainwreck during the Hard Rain. No amount of sugar will make
            the CSS layout model sweeter than a human waste recycling plant. The most powerful tool -- really the only
            tool -- that helps with dealing with CSS is attitude. Specifically, this attitude: "it looks close enough."</p>

            <p>But it was a fun experiment. Except when I had to fight bugs in TypeScript (that still exist in new versions so
            my NPM build issues aren't the issue stressing me).</p>

            <h2>Usage</h2>
            <p>Create classes inheriting from CssClass, with properties that match the class (or other rule) CSS properties. In most
            cases these will need to be quoted. Their values can be strings, instances of the CssVariable class, or nested properties,
            which are simple text maps (for example, font = { weight: "bold" } is the same as setting "font-weight" = "bold"). 
            Call render$() to add the CSS to the page.</p>

            <p>Special properties all end in the $ character.</p>
            <code><pre>
            interface {
                selector$: string;              // selector for the rule. Required.
                media$?: string;                // @media element
                styleSheetParent$: HTMLElement; // A <style> element is created. This is where. Default document.head.
                styleSheetId$: string;          // The ID of the style element created. Autogenerated.
                scopeElement$?: HTMLElement;    // Set this if you want the CSS to apply only to an element or its children
                extends$?: RulesCanExtend | RulesCanExtend[];   // Inherit CSS from these classes. Allows multiple inheritance.
                nested$?: RulesCanNest | RulesCanNest[];        // See the & operator in SASS/LESS.
                revert$: boolean;                               // Set to true as a shortcut for "all" = "initial"
                render$(): void;                                // Add or update the <style> element, adding CSS styling
                remove$(): void;                                // Remove the <style> element, removing CSS styling
            }
            </pre></code>

            <p>When writing the class and using initializers, remember to use equals (=), not colon (:). This is important.
            Remember that this is Typescript. "class CLS { foo: 'bar' } is totally different from "var CLS = { foo: 'bar' }." In the
            first case, new objects look like this {}, and your resulting CSS class is empty.</p>

            <p>The CssStyleSheet is a collection of CssRule objects. CssVariable is a CSS custom property. CssInlineRule is a quick and
            dirty way to create a CssRule inline in code without creating a class.</p>`
        });
    }
}

export class Test014 extends TestCaseView {
    constructor() {
        super(new TestViewModel());
    }

    testCase(): void {
        try {
            // Demo storing styles somewhere other than the HEAD
            const randomStyleDiv = div({ id: 'somewhere-for-the-style' });
            this.testArea.appendChild(randomStyleDiv);

            const scopedDiv = div({ id: 'scoped', className: 'divparent' });
            scopedDiv.appendChild(paragraph('Hello World', { id: 'para' })).appendChild(paragraph()); // dummy p tag at end
            scopedDiv.appendChild(anchor('Test1', 'https://www.google.com', { id: 'a1' })).appendChild(paragraph()); // dummy p at end
            scopedDiv.appendChild(anchor('Test2', 'https://www.google.com', { id: 'a2', className: 'nested' })).appendChild(paragraph());
            this.testArea.appendChild(scopedDiv);

            const colorVar = new CssVariable("primary", "blue");

            class BorderBaseRule extends CssSimpleRule {
                "border-style" = "solid";
            }
            class BorderColorRule extends BorderBaseRule {
                "border-color" = "black";
                "border-bottom-width" = "10px";
            }
            class DivRule extends CssRule {
                selector$ = "div";
                "color" = colorVar;
                "font-size" = "20px";
                "font" = {
                    weight: "bold" // Demo nested properties: Only one level of nesting is allowed
                };

                extends$ = BorderColorRule; // Demo "multiple inheritance"
                nested$ = NestedRule; // Demo nested rules/selectors
                scopeElement$ = scopedDiv; // Demo fake scoping (shouldn't affect all the other divs on the page)

                constructor() {
                    super(randomStyleDiv);
                }
            }

            class NestedRule extends CssRule {
                selector$ = "& .nested"; // Note the SASS/LESS ampersand that forces a space. You could have also used " .nested" but that would look weird.
                "text-decoration" = "none";
            }

            const cssRule = new DivRule().render$();

            const divStyles = window.getComputedStyle(scopedDiv);
            const testAreaStyles = window.getComputedStyle(this.testArea);
            const textStyles = window.getComputedStyle(document.getElementById('para')!);
            const a1styles = window.getComputedStyle(document.getElementById('a1')!);
            const a2styles = window.getComputedStyle(document.getElementById('a2')!);

            this.log('Beginning tests. Warning: these tests are based on the default setup where I live.');
            this.log('They will fail in browsers with different CSS settings');

            assert(textStyles.getPropertyValue('font-size') === '20px', 'Direct string property is applied');
            assert(divStyles.getPropertyValue("border-color") === 'rgb(0, 0, 0)', 'Inherited property is applied (1 level deep)');
            assert(divStyles.getPropertyValue("border-style") === 'solid', 'Inherited property is applied (2 levels deep)');
            assert(a2styles.getPropertyValue('text-decoration')!.includes('none'), 'Nested rule is applied');
            assert(textStyles.getPropertyValue('color') === 'rgb(0, 0, 255)', 'CSS variable (custom property) is applied');
            assert(textStyles.getPropertyValue('font-weight') === '700', 'Nested property is applied');

            assert(testAreaStyles.getPropertyValue("border-style") === 'none', 'Scoped style stays in scoped element');

            class AllRed extends CssRule {
                selector$: string = 'page-router';
                'color' = 'red';
            }
            class WavyGravy extends CssRule {
                selector$: string = 'h1';
                'text-decoration' = 'wavy underline';
            }

            // A style sheet is little more than a collection of style rules
            const sheet1 = new CssStyleSheet([AllRed, WavyGravy], randomStyleDiv);
            sheet1.render();

            assert(window.getComputedStyle(document.querySelector('h1')!).getPropertyValue('color') === 'rgb(255, 0, 0)', 'Styles in stylesheet are applied and there is no scoping');
            assert(window.getComputedStyle(document.querySelector('h1')!).getPropertyValue('text-decoration')!.includes('wavy'), 'Multiple styles in stylesheet are applied');

            sheet1.remove();

            assert(window.getComputedStyle(document.querySelector('h1')!).getPropertyValue('color') === 'rgb(0, 0, 0)', 'Styles in stylesheet are removed');
            assert(!window.getComputedStyle(document.querySelector('h1')!).getPropertyValue('text-decoration')!.includes('wavy'), 'Multiple styles in stylesheet are removed');

            // Finally a more complex test. This resembles something you might actually use this for.
            class BtnBase extends CssRule {
                selector$ = ".btn";
                "display" = "inline-block";
                "font-weight" = "500";
                "text-align" = "center";
                "white-space" = "nowrap";
                "vertical-align" = "middle";
                "user-select" = "none";
                "border" = "1px solid transparent";
                "padding" = ".46875rem 1rem";
                "font-size" = "1rem";
                "line-height" = "1.5";
                "border-radius" = ".125rem";
                "transition" = "color 0.15s ease-in-out,background-color .15s ease-in-out,border-color 0.15s ease-in-out,box-shadow .15s ease-in-out";
                nested$ = [
                    new CssInlineRule("&:hover, &:hover", { "text-decoration": "none" }),
                    new CssInlineRule("&:focus, &.focus", { "outline": "none", "box-shadow": "none" }),
                    new CssInlineRule("&:disabled, &.disabled", { "opacity": ".65", "box-shadow": "none" }),
                    new CssInlineRule("&:not(:disabled):not(.disabled)", { cursor: "pointer" }),
                ];
            }

            class BtnPrimary extends CssRule {
                selector$ = "";
                "color" = "#fff";
                "background-color" = "#df382c";
                "border-color" = "#df382c";
                "box-shadow" = "none";
                nested$ = [
                    new CssInlineRule("&:hover", { "color": "#fff", "background-color": "#f22112", "border-color": "#ea1c0d" }),
                    new CssInlineRule("&.focus", { "box-shadow": "none, 0 0 0 .2rem rgba(244,67,54,.5)" }),
                    new CssInlineRule("&.disabled, &:disabled", { "color": "#fff", "background-color": "#df382c", "border-color": "#df382c" }),
                    new CssInlineRule("&:not(:disabled):not(.disabled).active, &:not(:disabled):not(.disabled):active", { "color": "#fff", "background-color": "#ea1c0d", "border-color": "#deb1b0c" }),
                    new CssInlineRule("&:not(:disabled):not(.disabled).active:focus, &:not(:disabled):not(.disabled):active:focus", { "box-shadow": "none,0 0 0 .2rem rgba(244,67,54,.5)" }),
                ];
            }
            class BtnSecondary extends CssRule {
                selector$ = "";
                "color" = "#fff";
                "background-color" = "#aea79f";
                "border-color" = "#aea79f";
                "box-shadow" = "none";
                nested$ = [
                    new CssInlineRule("&:hover", { "color": "#fff", "background-color": "#5a6268", "border-color": "#545b62" }),
                    new CssInlineRule("&.focus", { "box-shadow": "none, 0 0 0 .2rem rgba(208,7%,46%,.5)" }),
                    new CssInlineRule("&.disabled, &:disabled", { "color": "#fff", "background-color": "#aea79f", "border-color": "#aea79f" }),
                    new CssInlineRule("&:not(:disabled):not(.disabled).active, &:not(:disabled):not(.disabled):active", { "color": "#fff", "background-color": "#545b62", "border-color": "#4e555b" }),
                    new CssInlineRule("&:not(:disabled):not(.disabled).active:focus, &:not(:disabled):not(.disabled):active:focus", { "box-shadow": "none,0 0 0 .2rem rgba(208,7%,46%,.5)" }),
                ];
            }

            class BtnClass extends BtnBase {
                constructor(className: string, primary = true, parent?: HTMLElement) {
                    super(parent);
                    this.selector$ = '.' + className;
                    this.extends$ = this.extends$ || [];
                    if (!Array.isArray(this.extends$)) {
                        this.extends$ = [this.extends$];
                    }
                    if (primary) {
                        this.extends$.push(new BtnPrimary());
                    } else {
                        this.extends$.push(new BtnSecondary());
                    }
                }
            }

            // Now say I imported the BtnClass from some module.
            const buttonTest = this.testArea.appendChild(div());
            const btnPrimary = new BtnClass("btn-primary", true, buttonTest).render$();
            const btnSecondary = new BtnClass("btn-secondary", false, buttonTest).render$();

            this.testArea.appendChild(
                createHtml(`<div>
                    <button type="button" class="btn-primary">Ok</button>
                    <button type="button" class="btn-secondary">Not Ok</button>
                </div>
                `)
            );

            const allTheRules = getCssRulesInElement(buttonTest);
            this.log(allTheRules);

            this.log(`Test ${this.viewModel.testNumber}: Test successful`);

        } catch (err) {
            this.log("ERROR: " + err);
            throw err;
        }
    }
}
